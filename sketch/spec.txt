This document describes what the Web::URL::Parser module implements.
This is just a description; it does not use strict language
appropriate for specs.  It is built on the top of following specs:

- url-spec
- WA1 URL
- RFC 3986

* /encoding/

If the character encoding specified as /encoding/ is not an
ASCII-compatible character encoding [WA1], /encoding/ MUST be set to
UTF-8 instead.

* Unreserved characters

The *unreserved characters* are the following characters: U+002D (-),
U+002E (.), U+0030 (0) to U+0039 (9), U+0041 (A) to U+005A (Z), U+005F
(_), U+0061 (a) to U+007A (z), and U+007E (~).

A *non-unreserved octet* is an octet that does not represent an
unreserved character when the octet is interpreted as a US-ASCII
character.

* Valid scheme characters

The *valid scheme characters* [url-spec] are the following characters:
U+002B (+), U+002D (-), U+002E (.), U+0030 (0) to U+0039 (9), U+0041
(A) to U+005A (Z), U+005F (_), and U+0061 (a) to U+007A (z).

* Preprocessing of a string /s/

  Remove leading or trailing control characters [url-spec]. XXX need
  to study what browsers do once again.

  Replace any character in the following range by a U+FFFD REPLACEMENT
  CHARACTER: XXX This might be wrong.

    - U+D800 ... U+DFFF
    - U+FDD0 ... U+FDEF
    - U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, U+2FFFF, U+3FFFE,
      U+3FFFF, U+4FFFE, U+4FFFF, U+5FFFE, U+5FFFF, U+6FFFE, U+6FFFF,
      U+7FFFE, U+7FFFF, U+8FFFE, U+8FFFF, U+9FFFE, U+9FFFF, U+AFFFE,
      U+AFFFF, U+BFFFE, U+BFFFF, U+CFFFE, U+CFFFF, U+DFFFE, U+DFFFF,
      U+EFFFE, U+EFFFF, U+FFFFE, U+FFFFF, U+10FFFE, U+10FFFF
    - Non-Unicode characters

  XXX maybe white space characters should be removed here.

  XXX and U+0000 -> U+FFFD. (?)

* Parsing an absolute URL /s/

  Preprocess the string /s/.

  Apply url-spec's steps.

* Merge path

  Apply RFC 3986's steps, but use "slash character" definition instead
  of "/" character for comparison.

* Remove dot-segments from a string /s/

  Replace any U+005C REVERSE SOLIDUS (\) character in /s/ by a U+002F
  SOLIDUS (/) character.

  Apply RFC 3986's steps.

* IPv4 address

  A string /s/ is an IPv4 address if:

    Split /s/ by "." and let /host/ be the array of the result
    components, where |host[i]| represents the /i/-th component.  The
    first component is |host[0]|.

    Abort if /host/ contains no item.

    XXX The following algorithm is wrong for e.g. "192.168.1" or
    "192.168.0.266".

    addr[0] = 0; addr[1] = 0; addr[2] = 0; addr[3] = 0;
    j = 0;
    for (i = 0; i < host.length; i++) {
      n = number (host[i]);
      if (n == null || n > 0xFFFFFFFF) {
        abort ();
      } else if (n > 0xFFFFFF) {
        if (j > 0) abort ();
        addr[j + 0] = (n >> 24) & 0xFF;
        addr[j + 1] = (n >> 16) & 0xFF;
        addr[j + 2] = (n >>  8) & 0xFF;
        addr[j + 3] = (n >>  0) & 0xFF;
      } else if (n > 0xFFFF) {
        if (j > 1) abort ();
        addr[j + 0] = (n >> 16) & 0xFF;
        addr[j + 1] = (n >>  8) & 0xFF;
        addr[j + 2] = (n >>  0) & 0xFF;
      } else if (n > 0xFF) {
        if (j > 2) abort ();
        addr[j + 0] = (n >>  8) & 0xFF;
        addr[j + 1] = (n >>  0) & 0xFF;
      } else {
        if (j > 3) abort ();
        addr[j + 0] = (n >>  0) & 0xFF;
      }
    }

    Abort if more components in /host/.

    Then, /addr/ represents the IPv4 address.

  number (n) is:

    If /n/ is /\A0[Xx][0-9]*\z/, interpret as a hexadecimal number.

    If /n/ is /\A0[0-9]+\z/,

      If /n/ contains "8" or "9", return null.

      Otherwise, interpret as an octal number.

    If /n/ is /\A[0-9]+\z/, interpret as a decimal number.

    Otherwise, return null.

    Return the number.

  Canonical form of an IPv4 address /addr/ is:

    addr[0]'s shortest decimal representation using [0-9]
    "."
    addr[1]'s shortest decimal representation using [0-9]
    "."
    addr[2]'s shortest decimal representation using [0-9]
    "."
    addr[3]'s shortest decimal representation using [0-9]

* IPv6 address

  A string /s/ is an IPv6 address if: XXX.

  Canonical form of an IPv6 address /addr/ is: XXX.

* Resolution

  If parsing the base URL results in "invalid", the resolved URL
  cannot be resolved.  Abort the steps.

  Preprocess the resolved URL as /s/.

  Trim the control characters.

  Apply url-spec's steps.

  If the |scheme| components of resolved and base URLs differ, and if
  the resolved URL's scheme is hierarchical, parse the resolved URL as
  an absolute URL, and then remove dot-segments [RFC 3986] from the
  |path| component, if any.

** Resolve as a scheme-relative URL

  Remove dot-segments from the |path| component.

  Apply url-spec's steps.

** Resolve as a authority-relative URL

  Remove dot-segments from the |path| component.

  Apply url-spec's steps.

** Resolve as a path-relative URL

  Apply RFC 3986 algorithm.

* Percent-encode a character string /s/ using encoding /encoding/

  XXX This might be wrong: Replace each character in the following
  range in /s/ by a U+FFFD REPLACEMENT CHARACTER:

    - U+0000

  Replace each character in /s/ which cannot be represented in
  /encoding/ by a U+003F QUESTION MARK character (?).

  Encode /s/ in encoding /encoding/.

  Percent-encode non-unreserved octets in /s/.

* Nameprep a string /s/

  GECKO / IE: If /s/ contains U+0340 or U+0341, fail.

  Apply the Nameprep Mapping step to /s/.

  CHROME: Apply NFKC of Unicode 3.2 + Corrigendum #3 (- Corrigendum
  #4) + Corrigendum #5 to /s/.

  GECKO / IE: If there are Corrigendum 5 Sequences
  <http://www.unicode.org/reports/tr15/#Corrigendum_5_Sequences> in
  /s/, change the order of the second last and the last characters in
  the sequences.

  GECKO / IE: Apply NFKC of Unicode 4.0 (+ Corrigendum #3 + Corrigendum #4)
  + Corrigendum #5 to /s/.

  GECKO / IE: Apply the Nameprep Mapping step to /s/, again.

  Apply the Nameprep prohibit step [RFC 3491] to /s/.  This step might
  fail.

  Returns /s/.

* ToASCII a string /s/

  ...

    Remove U+0009, U+000A, U+000D from /s/.

    GECKO: Let /fallback/ be /s/.  CHROME / IE: Let /fallback/ be
    "fails".

    Let /fallback/ be ASCII lowercase variant of /fallback/.

    CHROME: Percent-decode /s/ and decode as UTF-8, with error handling.

    CHROME: If /s/ contains "%", abort.

    GECKO / IE: Apply the Nameprep algorithm with /s/ and let /s/ be
    the result.  If the algorithm fails, return /fallback/ and abort
    these steps.

    GECKO / IE: If /s/ contains U+0000 or U+0020:

      GECKO / IE: If /fallback/ contains U+0000 or U+0020, then abort the
      algorithm.

      GECKO / IE: Otherwise, if /fallback/ contains any character
      prohibited by Nameprep, return /fallback/.

    Replace any U+3002 IDEOGRAPHIC FULL STOP character, U+FF0E
    FULLWIDTH FULL STOP character, and U+FF61 HALFWIDTH IDEOGRAPHIC
    FULL STOP character, in /s/, by a U+002E FULL STOP character (.).

    Let /need-punycode/ be false.

    Split by "." and for each component /label/:

      CHROME: Percent-encode U+0020, U+0021 (!), U+0022 ("), U+0023 (#),
      U+0024 ($), U+0026 (&), U+0027 ('), U+0028 ((), U+0029 ()),
      U+002A (*), U+002C (,), U+003C (<), U+003D (=), U+003E (>),
      U+0040 (@), U+005E (^), U+0060 (`), U+007B ({), U+007C (|),
      U+007D (}) in /label/.

      If there is at least one non-ASCII character, set /true/ to the
      /need-punycode/ flag.

      CHROME: Apply the Nameprep algorithm with /label/ and let
      /label/ be the result.  If the algorithm fails, the ToASCII
      algorithm fails.  Abort the ToASCII algorithm.

      Apply the Nameprep bidi check step [RFC 3491] to /s/, GECKO / IE:
      using Unicode 3.2 or CHROME: using latest version of Unicode
      (Version 6.0.0 at the moment).  If it fails, return /fallback/
      and abort the ToASCII algorithm.

      CHROME: If /label/ begins with "xn--" and contains non-ASCII
      character, abort.

    If the /need-punycode/ flag is /true/,

      GECKO: 

        Let /tld/ be the last non-empty /label/, if any, or the empty
        string.

        Let /tld/ be "xn--" followed by Punycode encoded
        representation of /tld/ if /tld/ contains non-ASCII
        characters.

        Let /idn-enabled/ be whether /tld/ is in the list of
        IDN-enabled TLDs [MOZILLA] or not.

        Let /idn-enabled/ be false if a /label/ contains a character
        included in the list of IDN blacklist characters [MOZILLA].

      IE: Let /idn-enabled/ true.

      For each /label/,

        If /label/ contains a non-ASCII character,

          If /idn-enabled/ is false,

            Encode /label/ by Punycode and prepend "xn--". XXX if
            failed

            If /label/ contains more than 63 [GECKO / IE: 62] characters,
            abort the ToASCII algorithm.  GECKO / IE: Except when original
            /label/ has no non-ASCII character, in which case replace
            /label/ by its first 62 characters.

        Otherwise, if /label/ contains more than 63 [GECKO / IE: 62]
        characters, abort the ToASCII algorithm.  GECKO / IE: Except when
        original /label/ has no non-ASCII character, in which case
        replace /label/ by its first 62 characters.

      CHROME: If there are more than one empty /label/, if there is
      only a /label/ and the /label/ is the empty string, or if there
      is an empty /label/ that is not the last /label/, abort the
      ToASCII algorithm.

    Join /label/s by ".".

    CHROME: Percent-decode and interpret as U+0000 - U+00FF.
    Normalize to ASCII lower-case.

    CHROME: If /s/ contains at least one of the following characters,
    abort the ToASCII algorithm: U+0000, ..., U+001F, U+0025 (%),
    U+002F (/), U+003A (:), U+003B (;), U+003F (?), U+005C (\), U+005E
    (^), U+007E (~), U+007F, characters prohibitted by Nameprep.

    CHROME: Percent-encode U+0020, U+0021 (!), U+0022 ("), U+0023 (#),
    U+0024 ($), U+0026 (&), U+0027 ('), U+0028 ((), U+0029 ()), U+002A
    (*), U+002C (,), U+003C (<), U+003D (=), U+003E (>), U+0040 (@),
    U+005E (^), U+0060 (`), U+007B ({), U+007C (|), U+007D (}) in /s/.

    If /s/ is an IPv6 address, return the canonical representation of
    the IPv6 address and abort these steps.

    If /s/ contains "[" or "]", abort the ToASCII algorithm.

    If /s/ is an IPv4 address, return the canonical representation of
    the IPv4 address and abort these steps.

    Return /s/.

  XXX

  Percent-decode /s/ and decode as UTF-8.  XXX If it fails, ...

  Apply Nameprep.  XXX This is wrong.

  If the first character of /s/ is "[" and the last character of /s/
  is "]", XXX canonicalize as an IPv6 address, return the result, and
  abort these steps.

  If /s/ is an IPv4 address, return the canonical representation of
  the IPv4 address and abort these steps.

  Split by U+002E FULL STOP character (.).  Let /labels/ be the result
  (zero or more strings of zero or more characters.

  For each string /label/ in /labels/, apply the following steps:

    Apply Punycode encoding algorithm.  XXX If it fails, ...

    Prepend "xn--" to /label/.

    XXX Percent-encode /label/.

  Let /s/ be concatenation of /labels/ where each component is
  separated by a U+002E FULL STOP character (.).

  Return /s/.

  XXX



* Canonicalize a string /u/ by encoding /encoding/

  XXX Remove characters U+0009, U+000A, and U+000D from /u/.

  If there is the |scheme| component in /u/, replace the component by
  the same string converted to ASCII lowercase [WA1].

  If there is the |user| component or the |password| component in /u/:

    If there is the |password| component in /u/ and it is the empty
    string, remove the |password| component (and preceding U+003A
    COLON character (:)).

    If the |user| component is the empty string and there is no
    |password| component, remove the |user| component (and following
    U+0040 COMMERCIAL AT character (@)).

    Percent-encode characters EXCEPT for unreserved characters, U+0021
    (!), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028 ((),
    U+0029 ()), U+002A (*), U+002B (+), U+002D (,), in the |user|
    component of /u/, using encoding |UTF-8|.

    Percent-encode characters EXCEPT for unreserved characters, U+0021
    (!), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028 ((),
    U+0029 ()), U+002A (*), U+002B (+), U+002D (,), in the |password|
    component of /u/, using encoding |UTF-8|, if any.

  If there is the |host| component, invoke the ToASCII algorithm with
  the |host| and then:

    If the algorithm returns a string, then let the |host| component
    be the string.  The string can be the empty string.

    Otherwise, if the algorithm fails, /u/ is invalid.  Abort the
    entire steps.

  If there is the |port| component in /u/:

    If the |port| component is the empty string, remove the |port|
    component (and preceding U+003A COLON character (:)).

    Otherwise, if the |port| component consist of one or more sequence
    of characters in the range U+0030 to U+0039, inclusive:

      Interpret the |port| component as a decimal number and let /p/
      be that number.

      If /p/ is equal to the default port of the scheme of /u/, if
      any, remove the |port| component (and preceding U+003A COLON
      character (:)).

      Otherwise, if /p/ is less than or equal to 65535, replace the
      |port| component by the shortest representation of /p/ in
      decimal, using characters in the range U+0030 to U+0039,
      inclusive.

      Otherwise, /u/ is invalid.  Abort the entire steps.

    Otherwise, /u/ is invalid.  Abort the entire steps.

  XXX If no path

  Percent-decode percent-encoded representations of unreserved
  characters in the |path| component of /u/.

  Percent-encode characters EXCEPT for unreserved characters, U+0021
  (!), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028 ((),
  U+0029 ()), U+002A (*), U+002B (+), U+002D (,), U+002F (/), U+003A
  (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([), U+005D (]), in
  the |path| component of /u/, using encoding |UTF-8|.

  Percent-encode characters EXCEPT for unreserved characters, U+0021
  (!), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028 ((),
  U+0029 ()), U+002A (*), U+002B (+), U+002D (,), U+002F (/), U+003A
  (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([), U+005D (]),
  U+005C (\), U+005E (^), U+0060 (`), U+007B ({), U+007C (|), U+007D
  (}), in the |query| component of /u/, using encoding /encoding/
  [WA1].

  Percent-encode characters U+0000 ... U+0020, U+0022 ("), U+003C (<),
  U+003E (>), U+007F ... U+009F, in the |fragment| component of /u/,
  using encoding |UTF-8|.

  XXX Non-hierarchical

  XXX Non-http

* Serialization of parsed URL

  If the parsed URL is /invalid/, abort these steps.

  Let /s/ be the empty string.

  Append the |scheme| component to /s/.

  Append a U+003A COLON (:) character to /s/.

  If there is at least one of |user|, |password|, |host|, and |port|
  components (even if it is the empty string):

    Append |//| (two U+002F SOLIDUS (/) characters) to /s/.

    If there is at least one of |user| and |password| component (even
    if it is the empty string):

      Append the |user| component, if any, to /s/.

      If there is the |password| component (even if it is the empty
      string):

        Append a U+003A COLON (:) character to /s/.

        Append the |password| component to /s/.

      Append a U+0040 COMMERCIAL AT (@) character to /s/.

    Append the |host| component, if any, to /s/.

    If there is the |port| component (even if it is the empty string):

      Append a U+003A COLON (:) character to /s/.

      Append the |port| component to /s/.

  Append the |path| component, if any, to /s/.

  If there is the |query| component (even if it is the empty string):

    Append a U+003F QUESTION MARK (?) character to /s/.

    Append the |query| component to /s/.

  If there is the |fragment| component (even if it is the empty
  string):

    Append a U+0023 NUMBER SIGN (#) character to /s/.

    Append the |fragment| component to /s/.

  Return /s/.
