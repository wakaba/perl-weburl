This document describes what the Web::URL::Parser module implements.
This is just a description; it does not use strict language
appropriate for specs.  It is built on the top of following specs:

- url-spec <http://tools.ietf.org/html/draft-abarth-url-00>
- WA1 URL
- RFC 3986

  XXX <http://tools.ietf.org/html/draft-abarth-url-01>

* /encoding/

If the character encoding specified as /encoding/ is not an
ASCII-compatible character encoding [WA1], /encoding/ MUST be set to
UTF-8 instead.

* Unreserved characters

The *unreserved characters* are the following characters: U+002D (-),
U+002E (.), U+0030 (0) to U+0039 (9), U+0041 (A) to U+005A (Z), U+005F
(_), U+0061 (a) to U+007A (z), and U+007E (~).

A *non-unreserved octet* is an octet that does not represent an
unreserved character when the octet is interpreted as a US-ASCII
character.

* Valid scheme characters

The *valid scheme characters* [url-spec] are the following characters:
U+002B (+), U+002D (-), U+002E (.), U+0030 (0) to U+0039 (9), U+0041
(A) to U+005A (Z), U+005F (_), and U+0061 (a) to U+007A (z).

* Hierarchicalness

  Following schemes are *hierarchical*:

    - http
    - https

  Following schemes are /not/ hierarchical:

    - about
    - data
    - javascript
    - mailto

  Whether the other schemes are hierarchical or not is /unknown/.

  A URL is *hierarchical* if one of the following conditions is met:

    - It's |scheme| is *hierarchical*, or

    - Whether it's |scheme| is hierarchical or not is /unknown/ and
      the URL is the |scheme| component followed by a U+003A COLON
      character (:) followed by a U+002F SOLIDUS character (/)
      followed by zero ore more characters.

* Authority terminating characters

Remove U+003B (;) from "authority terminating characters" [url-spec].

* Preprocessing of a string /s/

  Remove leading or trailing control characters [url-spec]. XXX need
  to study what browsers do once again.

  Replace any character in the following range by a U+FFFD REPLACEMENT
  CHARACTER: XXX This might be wrong.

    - U+D800 ... U+DFFF
    - U+FDD0 ... U+FDEF
    - U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, U+2FFFF, U+3FFFE,
      U+3FFFF, U+4FFFE, U+4FFFF, U+5FFFE, U+5FFFF, U+6FFFE, U+6FFFF,
      U+7FFFE, U+7FFFF, U+8FFFE, U+8FFFF, U+9FFFE, U+9FFFF, U+AFFFE,
      U+AFFFF, U+BFFFE, U+BFFFF, U+CFFFE, U+CFFFF, U+DFFFE, U+DFFFF,
      U+EFFFE, U+EFFFF, U+FFFFE, U+FFFFF, U+10FFFE, U+10FFFF
    - Non-Unicode characters

  XXX and U+0000 -> U+FFFD. (?)

  Remove characters U+0009, U+000A, and U+000D from /s/.

* Parsing an absolute URL /s/

  Preprocess the string /s/.

  If /s/ is hierarchical, apply url-spec's steps for hierarchical
  URLs.

  Otherwise, apply url-spec's steps for non-hierarchical URLs.

* Parsing a mailto: URL /s/

  If /s/ contains a U+003F QUESTION MARK character (?), split /s/ by
  the first such character into two parts.  The first part is the path
  component of the URL and the second part is the query component of
  the URL.  These components do not include the U+003F QUESTION MARK
  character (?) used to split the string and might be empty strings.
  The URL has no authority and fragment components.

  Otherwise, /s/ is the path component of the URL.  The URL has no
  authority, query, and fragment components.

* Merge path

  Apply RFC 3986's steps, but use "slash character" definition instead
  of "/" character for comparison.

* Remove dot-segments from a string /s/

  Replace any U+005C REVERSE SOLIDUS (\) character in /s/ by a U+002F
  SOLIDUS (/) character.

  Apply RFC 3986's steps.

* IPv4 addresses

  A string /s/ is an IPv4 address if one of the following conditions
  is met:

    - Four numbers concatenated by a U+002E FULL STOP character (.),
      where all numbers are greater than or equal to zero (0) and less
      than or eqaul to 255 (0xFF).

    - Three numbers concatenated by a U+002E FULL STOP character (.),
      where first two numbers are greater than or equal to zero (0)
      and less than or eqaul to 255 (0xFF) and the last number is
      greater than or equal to zero (0) and less than or equal to
      65535 (0xFFFF).

    - Two numbers concatenated by a U+002E FULL STOP character (.),
      where the first number is greater than or equal to zero (0) and
      less than or eqaul to 255 (0xFF) and the last number is greater
      than or equal to zero (0) and less than or equal to 16777215
      (0xFFFFFF).

    - A number which is greater than or equal to zero (0) and less
      than or equal to 4294967295 (0xFFFFFFFF).

  In this definition, numbers are represented in the form of one of
  the following character sequences:

    - A U+0030 DIGIT ZERO character (0), followed by U+0058 LATIN
      CAPITAL LETTER X character (X) or U+0078 LATIN SMALL LETTER X
      character (x), followed by zero or more hexadecimal digits,
      i.e. characters in the range U+0030 ... U+0039, U+0041
      ... U+0046, and U+0061 ... U+0066.  The value of this number is
      represented by the hexadecimal digits in the sequence.  If no
      hexadecimal digit is contained, the value of the number is zero
      (0).

    - A U+0030 DIGIT ZERO character (0), followed by zero or more
      octal digits, i.e. characters in the range U+0030 ... U+0037.
      The value of this number is represented by the octal digits in
      the sequence.

    - Characters in the range U+0031 ... U+0039, followed by zero or
      more characters in the range U+0030 ... U+0039.  The value of
      this number is represented by the characters in the sequence,
      interpreted as decimal number.

  The rules for canonicalizing an IPv4 address are given in the
  following algorithm, which return an IPv4 address in its canonical
  form, or the "fail" state:

    1. Let /s/ be the given string.

    2. Let /addr/ be a 32-bit unsigned number.  In the following
       steps, the notation /addr[i]/ represents the /i/-th bit of
       /addr/, where /addr[0]/ is the least significant bit and
       /addr[31]/ is the most significant bit of the number.  In this
       context, a bit sequence /addr[i + j - 1]/ ... /addr[i]/ can be
       interpreted as a /j/-bit unsigned number, where /addr[i + j -
       1]/ is the most significant bit.

    3. If /s/ is an IPv4 address with four numbers, let /addr[31]/
       ... /addr[24]/ be the first number, let /addr[23]/
       ... /addr[16]/ be the second number, let /addr[15]/
       ... /addr[8]/ be the third number, and let /addr[7]/
       ... /addr[0]/ be the last number.

    4. Otherwise, if /s/ is an IPv4 address with three numbers, let
       /addr[31]/ ... /addr[24]/ be the first number, let /addr[23]/
       ... /addr[16]/ be the second number, and let /addr[15]/
       ... /addr[0]/ be the last number.

    5. Otherwise, if /s/ is an IPv4 address with two numbers, let
       /addr[31]/ ... /addr[24]/ be the first number, let /addr[23]/
       ... /addr[0]/ be the last number.

    6. Otherwise, if /s/ is an IPv4 address with a number, let /addr/
       be the number.

    7. Otherwise, return "fail" and abort these steps.

    8. Return a string consist of the following substrings, in this
       order:

         1. The number /addr[31]/ ... /addr[24]/

         2. A U+002E FULL STOP character (.)

         3. The number /addr[23]/ ... /addr[16]/

         4. A U+002E FULL STOP character (.)

         5. The number /addr[15]/ ... /addr[8]/

         6. A U+002E FULL STOP character (.)

         7. The number /addr[7]/ ... /addr[0]/

       Numbers are represented by decimal digits, i.e. characters in
       the range U+0030 ... U+0039, in the shortest form.

      NOTE: This definition of IPv4 addresses originally come from the
      UNIX |inet_addr()| function
      <http://pubs.opengroup.org/onlinepubs/9699919799/functions/inet_addr.html>
      [POSIX].

* IPv6 addresses

  The rules for canonicalizing an IPv6 address are given in the
  following algorithm, which return an IPv6 address in its canonical
  form, or the "fail" state:

    1. Let /s/ be the given string.

    2. If /s/ matches to the |IPv6address| production rule [RFC 3986]
       using the modified |IPv4address| production rule:

      IPv4address = octet "." octet "." octet "." octet
      octet = dec-octet / "00" DIGIT / "0" DIGIT DIGIT

       ... then, /s/ can be interpreted as an IPv6 address.  Return
       the canonical representation of the IPv6 address and abort
       these steps.

    3. Otherwise, return "fail" and abort these steps.

  The canonical representation of an IPv6 address is the textual
  representation of the IPv6 address conforming to the recommendation
  for the IPv6 text representation as described in RFC 5952 Section 4.

* Resolution

  If parsing the base URL results in "invalid", the resolved URL
  cannot be resolved.  Abort the steps.

  Preprocess the resolved URL as /s/.

  Trim the control characters.

  Apply url-spec's steps.

  If the |scheme| components of resolved and base URLs differ, and if
  the resolved URL's scheme is hierarchical, parse the resolved URL as
  an absolute URL, and then remove dot-segments [RFC 3986] from the
  |path| component, if any.

** Resolve as a relative URL

  If relative-url is empty: follow url-spec's steps.

  Otherwise, if base-url's |scheme| component is not hierarchical,
  return "invalid" and abort these steps.

  XXX Unknown non-hierarchical URL schemes

  Otherwise: follow url-spec's steps.

** Resolve as a scheme-relative URL

  Remove dot-segments from the |path| component.

  Apply url-spec's steps.

** Resolve as a authority-relative URL

  Remove dot-segments from the |path| component.

  Apply url-spec's steps.

** Resolve as a path-relative URL

  Apply RFC 3986 algorithm.

* Percent-encode a character string /s/ using encoding /encoding/

  XXX This might be wrong: Replace each character in the following
  range in /s/ by a U+FFFD REPLACEMENT CHARACTER:

    - U+0000

  Replace each character in /s/ which cannot be represented in
  /encoding/ by a U+003F QUESTION MARK character (?).

  Encode /s/ in encoding /encoding/.

  Percent-encode non-unreserved octets in /s/.

* Domain name canonicalization

Domain name canonicalization is apparently a disaster zone - five
major browsers do completely different canonicalization and there is
no interoperatibility at all on their IDN handling.

Therefore it is difficult to define the behavior we should follow
here.  Following steps are approximations of what browsers do.  It
should contain some mistakes, as their behavior are too complex to
understand perfectly.  Needless to say, no formal spec has succeeded
to document this situation.

Markers "CHROME", "GECKO", and "IE" are used in following steps.

The marker "THIS" denotes the steps chosen by THIS specification.
They are determined such that the algorithm (hopefully) conforms to
the following criteria:

  - The algorithm should be as simple and sane as possbile.

  - The algorithm should result in same output as browsers if Chrome,
    Gecko, and IE generate the same result.

  - The output should only contain ASCII characters allowed in URLs.

  - Percent-encoded and decoded sequences should be equivalent as long
    as they represents an unreserved character or an character that
    cannot be used in URLs.

  - Percent-encoded sequences should be interpreted either as a UTF-8
    string or as an invalid sequence.

  - The algorithm should be idempotent.

  - The algorithm should not disallow use of code points where
    characters are assgined after Unicode 3.2.

  - It should allow use of non-conforming ASCII domain names in the
    wild.

  - It should allow use of IDNs valid in both IDNA2003 and IDNA2008,
    independent of whether they are percent-encoded or not, and
    Punycode-encoded or not.

Steps without any marker apply to all browsers and "THIS"
specification.  Steps with marker apply to the specified ones only.

** The Nameprep algorithm

This is a modified version of the Nameprep algorithm [NAMEPREP].  It
returns either a string or the "fail" state.

  1. Let /s/ be the given string.

  2. GECKO: If /s/ contains U+0340 COMBINING GRAVE TONE MARK character
  or U+0341 COMBINING ACUTE TONE MARK character, return "fail" and
  abort the Nameprep algorithm.

  3. Apply /s/ the Map step [STRINGPREP] [NAMEPREP].

  4. GECKO: If there are Corrigendum 5 Sequences
  <http://www.unicode.org/reports/tr15/#Corrigendum_5_Sequences> in
  /s/, swap the second last and the last characters in the sequences.

      NOTE: This step emulates Gecko's behavior that does not support
      Corrigendum 5.

  5. Let /has-unassigned/ be false.

  6. THIS/GECKO: Let /has-unassigned/ be true if /s/ contains a code
     point which is contained in the table of unassigned code points
     as of Unicode 3.2.0 (See Appendix A.1 of RFC 3454) [STRINGPREP].

  7. Apply /s/ the following variant of NFKC [Unicode]:

    THIS: Latest version of Unicode (including Corrigendum #3,
    Corrigendum #4, and Corrigendum #5).

    GECKO: Unicode 4.0.0 (including Corrigendum #3 and Corrigendum #4)
    with Corrigendum #5.

    CHROME: Unicode 3.2.0 with Corrigendum #3 and Corrigendum #5
    (without Corrigendum #4).

    IE: Unicode 3.2.0 with Corrigendum #3 and Corrigendum #5 (without
    Corrigendum #4).

  8. THIS/GECKO: If /has-unassigned/ is true, apply /s/ the Map step
     [STRINGPREP] [NAMEPREP], again.

  9. THIS/GECKO: Apply /s/ the variant of NFKC as described in Step 7.

      NOTE: Steps 8 and 9 ensure that /s/ does not contain uppercase
      letters generated by NFKC.  As the Map step followed by NFKC is
      idempotent, checking of the /has-unassigned/ flag can be
      omitted.

  10. Apply /s/ the Prohibit step [STRINGPREP] [NAMEPREP].  If it
      fails, return "fail" and abort the Nameprep algorithm.

  11. If the algorithm is invoked with bidi checking: Apply Check bidi
      step [STRINGPREP] [NAMEPREP], using:

    THIS: Latest version of Unicode.

    CHROME: Latest version of Unicode (Version 6.0.0 at the time of
    writing).

    IE/GECKO: Unicode 3.2.0.

        NOTE: In IE, Nameprep check bidi step is somewhat more complex
        than Stringprep's one.

  12. Return /s/.

** The CanonicalizeHost algorithm

This algorithm returns either a string or the "fail" state.

  1. Let /s/ be the given string.

  2. Remove U+0009 CHARACTER TABULATION character, U+000A LINE FEED
     character, and U+000D CARRIAGE RETURN character from /s/.

  3. Let /fallback/ be "fail".

  4. GECKO: Let /fallback/ be /s/, converted to ASCII lowercase [WA1].

  5. THIS: If /s/ begins by "%5B" or "%5b", return /fallback/ and
     abort the CanonicalizeHost algorithm.

  6. THIS/CHROME: For any percent-encoded substring /ss/ in /s/,

    1. Percent-decode /ss/.

    2. Decode /ss/ as UTF-8, with error handling [WA1].

  7. IE: Replace following percent-encoded sequences (ASCII
     case-insensitive) by its percent-decoded representation:

    %00 .. %1F, %20, %22, %2D .. %2F, %30 .. %39, %3C, %3E, %3F, %41
    .. %5A, %5C, %5E .. %7F
    
        NOTE: These percent-encoded sequences represents ASCII
        characters that are not allowed in URLs, ASCII digits, ASCII
        latin characters, "-", "_", and ".".

  8. Let /has-root-dot/ be false.

  9. Let /need-punycode/ be true if /s/ contains a non-ASCII
     character, or false otherwise.

  10. CHROME/IE: If the last character of /s/, if any, is a label
      separator [RFC 3490], let /has-root-dot/ be true and remove the
      character.
 
  11. THIS/GECKO/IE: Invoke the Nameprep algorithm without bidi
      checking with /s/.  If the algorithm returns a string, let /s/
      be the string.  Otherwise, return /fallback/ and abort the
      CanonicalizeHost algorithm.

  12. CHROME: If /s/ contains a U+0025 PERCENT SIGN character (%),
      return /fallback/ and abort the CanonicalizeHost algorithm.

  13. GECKO: If /s/ contains a U+0000 NULL character or a U+0020 SPACE
      character:

    1. If /fallback/ contains a U+0000 NULL character or a U+0020
       SPACE character, return "fail" and abort the CanonicalizeHost
       algorithm.

    2. Otherwise, if /fallback/ contains any character disallowed by
       the "Prohibit" step of Nameprep [RFC 3491, RFC 3454], return
       /fallback/ and abort the CanonicalizeHost algorithm.

  14. CHROME: Percent-encode following characters in /s/: U+0020,
      U+0021 (!), U+0022 ("), U+0023 (#), U+0024 ($), U+0026 (&),
      U+0027 ('), U+0028 ((), U+0029 ()), U+002A (*), U+002C (,),
      U+003C (<), U+003D (=), U+003E (>), U+0040 (@), U+005E (^),
      U+0060 (`), U+007B ({), U+007C (|), and U+007D (}).

  15. Replace any label separator [RFC 3490] in /s/ by a U+002E FULL
      STOP character (.).

  16. THIS: If the last character of /s/, if any, is U+002E FULL STOP
      character (.), let /has-root-dot/ be true and remove the
      character.

  17. Split /s/ by U+002E FULL STOP character (.) and let /labels/ be
      the result.  /labels/ is a list of one or more strings, where
      some of strings could be empty.

  18. IE: If any string in /labels/ begins with "xn--", let
      /need-punycode/ be true.

  19. Let /idn-enabled/ be false.

  20. If the /need-punycode/ flag is true,

    1. GECKO: Check the TLD by following the steps below:

      1. Let /tld/ be the last non-empty string in /labels/, if any,
         or the empty string.

      2. If /tld/ contains a non-ASCII character,

        2.1. Encode /tld/ by Punycode [RFC 3492].  If the algorithm
             fails, let /tld/ be the empty string.

        2.2. Prepend "xn--" to /tld/ unless it is the empty string.

      3. Let /idn-enabled/ be whether /tld/ is in the list of
         IDN-enabled TLDs or not [WHITELIST].

      4. Let /idn-enabled/ be false if /s/ contains a character
         included in the list of IDN blacklist characters [BLACKLIST].

    2. For each item /label/ in /labels/,

      1. THIS/GECKO/CHROME:

        1. Invoke the Nameprep algorithm (including bidi checking)
           with /label/.  If the algorithm returns a string, let
           /label/ be the string.  Otherwise, return /fallback/ and
           abort the CanonicalizeHost algorithm.

            NOTE: For "THIS" and "GECKO", only the Check bidi step
            need to be applied here, as the Nameprep algorithm without
            bidi checking is invoked in an earlier step.

        2. If /label/ contains a non-ASCII character,

          1. If /idn-enabled/ is false,

            1. THIS/CHROME: If /label/ begins with "xn--" and contains
               non-ASCII character, return /fallback/ and abort the
               CanonicalizeHost algorithm.

            2. Encode /label/ by Punycode [RFC 3492].  If it fails,
               return /fallback/ and abort the CanonicalizeHost
               algorithm.

            3. Prepend "xn--" to /label/.

            4. If /label/ contains more than 63 characters, return
               /fallback/ and abort the CanonicalizeHost algorithm.

        3. Otherwise, if /label/ contains no non-ASCII character,

          1. GECKO: Let /label/ be first 62 characters of it if it
             contains more than 62 characters.

          2. THIS/CHROME: If /label/ is the empty string, return
             /fallback/ and abort the CanonicalizeHost algorithm.

          3. If /label/ contains more than 63 characters, return
             /fallback/ and abort the CanonicalizeHost algorithm.

      2. IE: Apply the modified ToUnicode operation [RFC 3490] as
         follows:

        1. If /label/ contains a non-ASCII character,

          1. Encode /label/ by Punycode [RFC 3492].  If it fails,
             return /fallback/ and abort the CanonicalizeHost
             algorithm.

          2. Prepend "xn--" to /label/.
        
        2. Let /p_label/ be /label/.

        3. If /label/ begins with "xn--",

          1. Remove "xn--" prefix from /label/.

          2. Decode /label/ by Punycode decode algorithm.  If it
             fails, return /fallback/ and abort the CanonicalizeHost
             algorithm.

        4. Apply ToASCII operation [RFC 3490] to /label/, with the
           UseSTD3ASCIIRules flag set (and without AllowUnassigned
           flag), and let /a_label/ be the output.  Note that the
           Nameprep algorithm defined by this specification is invoked
           within the ToASCII operation.  If the ToASCII operation
           fails, return /fallback/ and abort the CanonicalizeHost
           algorithm.

        5. If /a_label/ is different from /p_label/, return /fallback/
           and abort the CanonicalizeHost algorithm.

        6. If /label/ contains a U+3002 IDEOGRAPHIC FULL STOP
           character, return /fallback/ and abort the CanonicalizeHost
           algorithm.

  21. Let /s/ be the concatenation of the strings in /labels/ by
      U+002E FULL STOP character (.).

  22. If /has-root-dot/ is true, append a U+002E FULL STOP character
      (.) to /s/.

  23. CHROME: Replace any percent-encoded octets in /s/ by a character
      in the range U+0000-U+00FF.

  24. CHROME: Convert /s/ to ASCII lowercase [WA1].

  25. If /s/ begins with a U+005B LEFT SQUARE BRACKET character ([)
      and ends by a U+005D RIGHT SQUARE BRACKET character (]):

    1. Let /t/ be /s/.

    2. Remove the first character from /t/.

    3. Remove the last character from /t/.

    4. Invoke the rules for canonicalizing an IPv6 address with /t/.
       If it results in a string, return a U+005B LEFT SQUARE BRACKET
       character ([) followed by the string followed by a U+005D RIGHT
       SQUARE BRACKET character (]), and abort the CanonicalizeHost
       algorithm.

    NOTE: How broken host components contianing "[" and/or "]"
    characters are handled not always compatible with browsers, as
    browsers canonicalize them differently and none of them could be
    considered as sane and idempotent.

  26. THIS: Otherwise, if /s/ contains a U+0030 COLON character (:),
      return /fallback/ and abort the CanonicalizeHost algorithm.

  27. Invoke the rules for canonicalizing an IPv4 address with /s/.
      If it results in a string, return the string and abort the
      CanonicalizeHost algorithm.

  28. If /s/ contains one of the following characters, return
      /fallback/ and abort the CanonicalizeHost algorithm:

      THIS: U+0000, U+002F (/), U+0025 (%), U+003B (;), U+003F (?), or
      U+005C (\).

      CHROME: U+0000, ..., U+001F, U+0025 (%), U+002F (/), U+003A (:),
      U+003B (;), U+003F (?), U+005B ([), U+005C (\), U+005D (]),
      U+005E (^), U+007E (~), or U+007F.

      IE: U+0000, U+002F (/), U+003F (?), or U+005C (\).

      GECKO: None.

  29. IE: If /s/ contains one of the following sequences, return
      /fallback/ and abort the CanonicalizeHost algorithm: "%00" or
      "%" not followed by two hexadecimal digits.

  30. Percent-encode following characters in /s/:

    THIS: U+0000-U+001F, U+0020, U+0021 (!), U+0022 ("), U+0023 (#),
    U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028 ((), U+0029
    ()), U+002A (*), U+002C (,), U+002F (/), U+003B (;), U+003C (<),
    U+003D (=), U+003E (>), U+003F (?), U+0040 (@), U+005C (\), U+005E
    (^), U+0060 (`), U+007B ({), U+007C (|), U+007D (}), U+007F.

        NOTE: These are ASCII characters not allowed in URLs,
        delimiter characters used before or after the |host|
        component, characters percent-encoded in Chrome (See Step 27),
        ";", and "%".  Characters ":", "[", and "]", used to represent
        IPv6 addresses, are not percent-encoded here.

    IE: U+0000-U+001F, U+0020, U+0022 ("), U+003C (<), U+003E (>),
    U+005C (\), U+005E (^), U+0060 (`), U+007B ({), U+007C (|), U+007D
    (}), U+007F.  Use lowercase letters to represent hexadeciamal
    numbers.

    CHROME: U+0020, U+0021 (!), U+0022 ("), U+0023 (#), U+0024 ($),
    U+0026 (&), U+0027 ('), U+0028 ((), U+0029 ()), U+002A (*), U+002C
    (,), U+003C (<), U+003D (=), U+003E (>), U+0040 (@), U+005E (^),
    U+0060 (`), U+007B ({), U+007C (|), and U+007D (}).

    GECKO: None.

  31. Return /s/.

* Canonicalize a string /u/ by encoding /encoding/

  If there is the |scheme| component in /u/, replace the component by
  the same string converted to ASCII lowercase [WA1].

  If there is the |user| component or the |password| component in /u/:

    If there is the |password| component in /u/ and it is the empty
    string, remove the |password| component (and preceding U+003A
    COLON character (:)).

    If the |user| component is the empty string and there is no
    |password| component, remove the |user| component (and following
    U+0040 COMMERCIAL AT character (@)).

    Percent-encode characters in the |user| component of /u/, using
    the UTF-8 characters, EXCEPT for unreserved characters, U+0021
    (!), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028 ((),
    U+0029 ()), U+002A (*), U+002B (+), and U+002D (,).

    Percent-encode characters, in the |password| component of /u/, if
    any, using the UTF-8 encoding, EXCEPT for unreserved characters,
    U+0021 (!), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028
    ((), U+0029 ()), U+002A (*), U+002B (+), and U+002D (,).

  If there is the |host| component, invoke the CanonicalizeHost
  algorithm with the |host| and then:

    If the algorithm returns a string, then let the |host| component
    be the string.  The string can be the empty string.

    Otherwise, if the algorithm fails, /u/ is invalid.  Abort the
    entire steps.

  If there is the |port| component in /u/:

    If the |port| component is the empty string, remove the |port|
    component (and preceding U+003A COLON character (:)).

    Otherwise, if the |port| component consist of one or more sequence
    of characters in the range U+0030 to U+0039, inclusive:

      Interpret the |port| component as a decimal number and let /p/
      be that number.

      If /p/ is equal to the default port of the scheme of /u/, if
      any, remove the |port| component (and preceding U+003A COLON
      character (:)).

      Otherwise, if /p/ is less than or equal to 65535, replace the
      |port| component by the shortest representation of /p/ in
      decimal, using characters in the range U+0030 to U+0039,
      inclusive.

      Otherwise, /u/ is invalid.  Abort the entire steps.

    Otherwise, /u/ is invalid.  Abort the entire steps.

  If the scheme of /u/ is hierarchical and /u/ does not have the
  |path| component or the |path| component is the empty string, let
  the |path| component be a U+002F SOLIDUS character (/).

  If the scheme of /u/ is hierarchical, or if the |scheme| component
  of /u/ is ASCII case-insensitively equal to |mailto|:

    Percent-decode percent-encoded representations of unreserved
    characters in the |path| component of /u/.

    Percent-encode characters in the |path| component of /u/, using
    the UTF-8 encoding, EXCEPT for unreserved characters, U+0021 (!),
    U+0023 (#), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028
    ((), U+0029 ()), U+002A (*), U+002B (+), U+002D (,), U+002F (/),
    U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([), and
    U+005D (]).

  Otherwise, percent-encode characters in the |path| component of /u/,
  using the UTF-8 encoding, EXCEPT for characters in the range U+0020
  ... U+007E (inclusive).

      NOTE: ASCII characters not allowed in URLs are not
      percent-encoded here.

  Percent-encode characters in the |query| component of /u/, using
  encoding /encoding/, EXCEPT for unreserved characters, U+0021 (!),
  U+0023 (#), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028
  ((), U+0029 ()), U+002A (*), U+002B (+), U+002D (,), U+002F (/),
  U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([), U+005D
  (]), U+005C (\), U+005E (^), U+0060 (`), U+007B ({), U+007C (|), and
  U+007D (}).

  Percent-encode the following characters in the |fragment| component
  of /u/, using the UTF-8 encoding: U+0000 ... U+0020, U+0022 ("),
  U+003C (<), U+003E (>), U+007F ... U+009F.

      NOTE: Non-ASCII characters other than C1 control characters are
      not percent-encoded here.  As a result, a canonicalized URL
      might contain non-ASCII characters in its |fragment| component.

* Serialization of parsed URL

  If the parsed URL is /invalid/, abort these steps.

  Let /s/ be the empty string.

  Append the |scheme| component to /s/.

  Append a U+003A COLON (:) character to /s/.

  If there is at least one of |user|, |password|, |host|, and |port|
  components (even if it is the empty string):

    Append |//| (two U+002F SOLIDUS (/) characters) to /s/.

    If there is at least one of |user| and |password| component (even
    if it is the empty string):

      Append the |user| component, if any, to /s/.

      If there is the |password| component (even if it is the empty
      string):

        Append a U+003A COLON (:) character to /s/.

        Append the |password| component to /s/.

      Append a U+0040 COMMERCIAL AT (@) character to /s/.

    Append the |host| component, if any, to /s/.

    If there is the |port| component (even if it is the empty string):

      Append a U+003A COLON (:) character to /s/.

      Append the |port| component to /s/.

  Append the |path| component, if any, to /s/.

  If there is the |query| component (even if it is the empty string):

    Append a U+003F QUESTION MARK (?) character to /s/.

    Append the |query| component to /s/.

  If there is the |fragment| component (even if it is the empty
  string):

    Append a U+0023 NUMBER SIGN (#) character to /s/.

    Append the |fragment| component to /s/.

  Return /s/.
