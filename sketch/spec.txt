This document describes what the Web::URL::Parser module implements.
This is just a description; it does not use strict language
appropriate for specs.  It is built on the top of following specs:

- url-spec
- WA1 URL
- RFC 3986

* /encoding/

If the character encoding specified as /encoding/ is not an
ASCII-compatible character encoding [WA1], /encoding/ MUST be set to
UTF-8 instead.

* Unreserved characters

The *unreserved characters* are the following characters: U+002D (-),
U+002E (.), U+0030 (0) to U+0039 (9), U+0041 (A) to U+005A (Z), U+005F
(_), U+0061 (a) to U+007A (z), and U+007E (~).

A *non-unreserved octet* is an octet that does not represent an
unreserved character when the octet is interpreted as a US-ASCII
character.

* Valid scheme characters

The *valid scheme characters* [url-spec] are the following characters:
U+002B (+), U+002D (-), U+002E (.), U+0030 (0) to U+0039 (9), U+0041
(A) to U+005A (Z), U+005F (_), and U+0061 (a) to U+007A (z).

* Preprocessing of a string /s/

  Remove leading or trailing control characters [url-spec]. XXX need
  to study what browsers do once again.

  Replace any character in the following range by a U+FFFD REPLACEMENT
  CHARACTER: XXX This might be wrong.

    - U+D800 ... U+DFFF
    - U+FDD0 ... U+FDEF
    - U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, U+2FFFF, U+3FFFE,
      U+3FFFF, U+4FFFE, U+4FFFF, U+5FFFE, U+5FFFF, U+6FFFE, U+6FFFF,
      U+7FFFE, U+7FFFF, U+8FFFE, U+8FFFF, U+9FFFE, U+9FFFF, U+AFFFE,
      U+AFFFF, U+BFFFE, U+BFFFF, U+CFFFE, U+CFFFF, U+DFFFE, U+DFFFF,
      U+EFFFE, U+EFFFF, U+FFFFE, U+FFFFF, U+10FFFE, U+10FFFF
    - Non-Unicode characters

  XXX maybe white space characters should be removed here.

  XXX and U+0000 -> U+FFFD. (?)

* Parsing an absolute URL /s/

  Preprocess the string /s/.

  Apply url-spec's steps.

* Merge path

  Apply RFC 3986's steps, but use "slash character" definition instead
  of "/" character for comparison.

* Remove dot-segments from a string /s/

  Replace any U+005C REVERSE SOLIDUS (\) character in /s/ by a U+002F
  SOLIDUS (/) character.

  Apply RFC 3986's steps.

* IPv4 address

  A string /s/ is an IPv4 address if:

    Split /s/ by "." and let /host/ be the array of the result
    components, where |host[i]| represents the /i/-th component.  The
    first component is |host[0]|.

    Abort if /host/ contains no item.

    XXX The following algorithm is wrong for e.g. "192.168.1" or
    "192.168.0.266".

    addr[0] = 0; addr[1] = 0; addr[2] = 0; addr[3] = 0;
    j = 0;
    for (i = 0; i < host.length; i++) {
      n = number (host[i]);
      if (n == null || n > 0xFFFFFFFF) {
        abort ();
      } else if (n > 0xFFFFFF) {
        if (j > 0) abort ();
        addr[j + 0] = (n >> 24) & 0xFF;
        addr[j + 1] = (n >> 16) & 0xFF;
        addr[j + 2] = (n >>  8) & 0xFF;
        addr[j + 3] = (n >>  0) & 0xFF;
      } else if (n > 0xFFFF) {
        if (j > 1) abort ();
        addr[j + 0] = (n >> 16) & 0xFF;
        addr[j + 1] = (n >>  8) & 0xFF;
        addr[j + 2] = (n >>  0) & 0xFF;
      } else if (n > 0xFF) {
        if (j > 2) abort ();
        addr[j + 0] = (n >>  8) & 0xFF;
        addr[j + 1] = (n >>  0) & 0xFF;
      } else {
        if (j > 3) abort ();
        addr[j + 0] = (n >>  0) & 0xFF;
      }
    }

    Abort if more components in /host/.

    Then, /addr/ represents the IPv4 address.

  number (n) is:

    If /n/ is /\A0[Xx][0-9]*\z/, interpret as a hexadecimal number.

    If /n/ is /\A0[0-9]+\z/,

      If /n/ contains "8" or "9", return null.

      Otherwise, interpret as an octal number.

    If /n/ is /\A[0-9]+\z/, interpret as a decimal number.

    Otherwise, return null.

    Return the number.

  Canonical form of an IPv4 address /addr/ is:

    addr[0]'s shortest decimal representation using [0-9]
    "."
    addr[1]'s shortest decimal representation using [0-9]
    "."
    addr[2]'s shortest decimal representation using [0-9]
    "."
    addr[3]'s shortest decimal representation using [0-9]

* IPv6 address

  A string /s/ is an IPv6 address if: XXX.

  Canonical form of an IPv6 address /addr/ is: XXX.

* Resolution

  If parsing the base URL results in "invalid", the resolved URL
  cannot be resolved.  Abort the steps.

  Preprocess the resolved URL as /s/.

  Trim the control characters.

  Apply url-spec's steps.

  If the |scheme| components of resolved and base URLs differ, and if
  the resolved URL's scheme is hierarchical, parse the resolved URL as
  an absolute URL, and then remove dot-segments [RFC 3986] from the
  |path| component, if any.

** Resolve as a scheme-relative URL

  Remove dot-segments from the |path| component.

  Apply url-spec's steps.

** Resolve as a authority-relative URL

  Remove dot-segments from the |path| component.

  Apply url-spec's steps.

** Resolve as a path-relative URL

  Apply RFC 3986 algorithm.

* Percent-encode a character string /s/ using encoding /encoding/

  XXX This might be wrong: Replace each character in the following
  range in /s/ by a U+FFFD REPLACEMENT CHARACTER:

    - U+0000

  Replace each character in /s/ which cannot be represented in
  /encoding/ by a U+003F QUESTION MARK character (?).

  Encode /s/ in encoding /encoding/.

  Percent-encode non-unreserved octets in /s/.

* Domain name canonicalization

Domain name canonicalization is apparently a disaster zone - five
major browsers do completely different canonicalization and there is
no interoperatibility at all on their IDN handling.

Therefore it is difficult to define the behavior we should follow
here.  Following steps are approximations of what browsers do.  It
should contain some mistakes, as their behavior are too complex to
understand perfectly.  Needless to say, no formal spec has succeeded
to document this situation.

Markers "CHROME", "GECKO", and "IE" are used in following steps.

The marker "THIS" denotes the steps chosen by THIS specification.
They are determined such that the algorithm (hopefully) conforms to
the following criteria:

  - The algorithm should be as simple and sane as possbile.

  - The output should only contain ASCII characters allowed in URLs.

  - Percent-encoded and decoded sequences should be equivalent as long
    as they represents an unreserved character or an character that
    cannot be used in URLs.

  - Percent-encoded sequences should be interpreted either as UTF-8
    string or as invalid sequence.

  - The algorithm should be idempotent.

  - The algorithm should not disallow use of characters added after
    Unicode 3.2.

  - It should allow use of non-conforming ASCII domain names in the
    wild.

Steps without any marker apply to all browsers and "THIS"
specification.  Steps with marker apply to the specified ones only.

** The Nameprep algorithm

This is a modified version of the Nameprep algorithm [RFC 3491].  It
returns either a string or the "fail" state.

  1. Let /s/ be the given string.

  2. GECKO: If /s/ contains U+0340 COMBINING GRAVE TONE MARK character
  or U+0341 COMBINING ACUTE TONE MARK character, return "fail" and
  abort the Nameprep algorithm.

  3. Apply /s/ the Map step [RFC 3491, RFC 3454].

  4. GECKO: If there are Corrigendum 5 Sequences
  <http://www.unicode.org/reports/tr15/#Corrigendum_5_Sequences> in
  /s/, swap the second last and the last characters in the sequences.

      NOTE: This step emulates Gecko's behavior that does not support
      Corrigendum 5.

  5. Apply /s/ the following variant of NFKC [Unicode]:

    THIS: Latest version of Unicode (including Corrigendum #3,
    Corrigendum #4, and Corrigendum #5).

    GECKO: Unicode 4.0 (including Corrigendum #3 and Corrigendum #4)
    with Corrigendum #5.

    CHROME: Unicode 3.2 with Corrigendum #3 and Corrigendum #5
    (without Corrigendum #4).

    IE: Unicode 3.2 with Corrigendum #3 and Corrigendum #5 (without
    Corrigendum #4).

  6. GECKO: Apply /s/ the Map step [RFC 3491, RFC 3454], again.

  7. Apply /s/ the Prohibit step [RFC 3491, RFC 3454].  If it fails,
     return "fail" and abort the Nameprep algorithm.

  8. If the algorithm is invoked with bidi checking: Apply Check bidi
     step [RFC 3491, RFC 3454], using:

    THIS: Latest version of Unicode.

    CHROME: Latest version of Unicode (Version 6.0.0 at the time of
    writing).

    IE/GECKO: Unicode 3.2.

        NOTE: In IE, Nameprep check bidi step is somewhat more complex
        than IDNA2003.

  9. Return /s/.

** The CanonicalizeHost algorithm

This algorithm returns either a string or the "fail" state.

  1. Let /s/ be the given string.

  2. Remove U+0009 CHARACTER TABULATION character, U+000A LINE FEED
     character, and U+000D CARRIAGE RETURN character from /s/.

  3. Let /fallback/ be "fail".

  4. GECKO: Let /fallback/ be /s/, converted to ASCII lowercase [WA1].

  5. THIS/CHROME: For any percent-encoded substring /ss/ in /s/,

    1. Percent-decode /ss/.

    2. Decode /ss/ as UTF-8, with error handling [WA1].

  6. IE: Replace following percent-encoded sequences (ASCII
     case-insensitive) by its percent-decoded representation:

    %00 .. %1F, %20, %22, %2D .. %2F, %30 .. %39, %3C, %3E, %3F, %41
    .. %5A, %5C, %5E .. %7F
    
        NOTE: These percent-encoded sequences represents ASCII
        characters that are not allowed in URLs, ASCII digits, ASCII
        latin characters, "-", "_", and ".".

  7. Let /has-root-dot/ be false.

  8. Let /need-punycode/ be true if /s/ contains a non-ASCII
     character, or false otherwise.

  9. THIS/CHROME/IE: If the last character of /s/, if any, is a label
     separator [RFC 3490], let /has-root-dot/ be true and remove the
     character.
 
  10. THIS/GECKO/IE: Invoke the Nameprep algorithm without bidi
      checking with /s/.  If the algorithm returns a string, let /s/
      be the string.  Otherwise, return /fallback/ and abort the
      CanonicalizeHost algorithm.

  11. CHROME: If /s/ contains a U+0025 PERCENT SIGN character (%),
      return /fallback/ and abort the CanonicalizeHost algorithm.

  12. GECKO: If /s/ contains a U+0000 NULL character or a U+0020 SPACE
      character:

    1. If /fallback/ contains a U+0000 NULL character or a U+0020
       SPACE character, return "fail" and abort the CanonicalizeHost
       algorithm.

    2. Otherwise, if /fallback/ contains any character disallowed by
       the "Prohibit" step of Nameprep [RFC 3491, RFC 3454], return
       /fallback/ and abort the CanonicalizeHost algorithm.

  13. CHROME: Percent-encode following characters in /s/: U+0020,
      U+0021 (!), U+0022 ("), U+0023 (#), U+0024 ($), U+0026 (&),
      U+0027 ('), U+0028 ((), U+0029 ()), U+002A (*), U+002C (,),
      U+003C (<), U+003D (=), U+003E (>), U+0040 (@), U+005E (^),
      U+0060 (`), U+007B ({), U+007C (|), and U+007D (}).

  14. Replace any label separator [RFC 3490] in /s/ by a U+002E FULL
      STOP character (.).

  15. Split /s/ by U+002E FULL STOP character (.) and let /labels/ be
      the result.  /labels/ is a list of one or more strings, where
      some of strings could be empty.

  16. IE: If any string in /labels/ begins with "xn--", let
      /need-punycode/ be true.

  17. Let /idn-enabled/ be false.

  18. If the /need-punycode/ flag is true,

    1. GECKO: Check the TLD by following the steps below:

      1. Let /tld/ be the last non-empty string in /labels/, if any,
         or the empty string.

      2. If /tld/ contains a non-ASCII character,

        2.1. Encode /tld/ by Punycode [RFC 3492].  If the algorithm
             fails, let /tld/ be the empty string.

        2.2. Prepend "xn--" to /tld/ unless it is the empty string.

      3. Let /idn-enabled/ be whether /tld/ is in the list of
         IDN-enabled TLDs or not [WHITELIST].

      4. Let /idn-enabled/ be false if /s/ contains a character
         included in the list of IDN blacklist characters [BLACKLIST].

    2. For each item /label/ in /labels/,

      1. THIS/GECKO/CHROME:

        1. Invoke the Nameprep algorithm (including bidi checking)
           with /label/.  If the algorithm returns a string, let
           /label/ be the string.  Otherwise, return /fallback/ and
           abort the CanonicalizeHost algorithm.

            NOTE: For "THIS" and "GECKO", only the Check bidi step
            need to be applied here, as the Nameprep algorithm without
            bidi checking is invoked in an earlier step.

        2. If /label/ contains a non-ASCII character,

          1. If /idn-enabled/ is false,

            1. CHROME: If /label/ begins with "xn--" and contains
               non-ASCII character, return /fallback/ and abort the
               CanonicalizeHost algorithm.

            2. Encode /label/ by Punycode [RFC 3492].  If it fails,
               return /fallback/ and abort the CanonicalizeHost
               algorithm.

            3. Prepend "xn--" to /label/.

            4. If /label/ contains more than 63 characters, return
               /fallback/ and abort the CanonicalizeHost algorithm.

        3. Otherwise, if /label/ contains no non-ASCII character,

          1. GECKO: Let /label/ be first 62 characters of it if it
             contains more than 62 characters.

          2. THIS/CHROME: If /label/ is the empty string, return
             /fallback/ and abort the CanonicalizeHost algorithm.

          3. If /label/ contains more than 63 characters, return
             /fallback/ and abort the CanonicalizeHost algorithm.

      2. IE: Apply the modified ToUnicode operation [RFC 3490] as
         follows:

        1. If /label/ contains a non-ASCII character,

          1. Encode /label/ by Punycode [RFC 3492].  If it fails,
             return /fallback/ and abort the CanonicalizeHost
             algorithm.

          2. Prepend "xn--" to /label/.
        
        2. Let /p_label/ be /label/.

        3. If /label/ begins with "xn--",

          1. Remove "xn--" prefix from /label/.

          2. Decode /label/ by Punycode decode algorithm.  If it
             fails, return /fallback/ and abort the CanonicalizeHost
             algorithm.

        4. Apply ToASCII operation [RFC 3490] to /label/, with the
           UseSTD3ASCIIRules flag set (and without AllowUnassigned
           flag), and let /a_label/ be the output.  Note that the
           Nameprep algorithm defined by this specification is invoked
           within the ToASCII operation.  If the ToASCII operation
           fails, return /fallback/ and abort the CanonicalizeHost
           algorithm.

        5. If /a_label/ is different from /p_label/, return /fallback/
           and abort the CanonicalizeHost algorithm.

        6. If /label/ contains a U+3002 IDEOGRAPHIC FULL STOP
           character, return /fallback/ and abort the CanonicalizeHost
           algorithm.

  19. Let /s/ be the concatenation of the strings in /labels/ by
      U+002E FULL STOP character (.).

  20. If /has-root-dot/ is true, append a U+002E FULL STOP character
      (.) to /s/.

  21. CHROME: Replace any percent-encoded octets in /s/ by a character
      in the range U+0000-U+00FF.

  22. CHROME: Convert /s/ to ASCII lowercase [WA1].

  23. If /s/ contains one of the following characters, return
      /fallback/ and abort the CanonicalizeHost algorithm:

      THIS/GECKO: None.

      CHROME: U+0000, ..., U+001F, U+0025 (%), U+002F (/), U+003A (:),
      U+003B (;), U+003F (?), U+005C (\), U+005E (^), U+007E (~), or
      U+007F.

      IE: U+0000, U+002F (/), U+003F (?), or U+005C (\).

  24. IE: If /s/ contains one of the following sequences, return
      /fallback/ and abort the CanonicalizeHost algorithm: "%00" or
      "%" not followed by two hexadecimal digits.

  25: THIS: Percent-encode following characters in /s/: U+0000-U+001F,
      U+0020, U+0021 (!), U+0022 ("), U+0023 (#), U+0024 ($), U+0025
      (%), U+0026 (&), U+0027 ('), U+0028 ((), U+0029 ()), U+002A (*),
      U+002C (,), U+002F (/), U+003A (:), U+003B (;), U+003C (<),
      U+003D (=), U+003E (>), U+003F (?), U+0040 (@), U+005C (\),
      U+005E (^), U+0060 (`), U+007B ({), U+007C (|), U+007D (}),
      U+007F.

      NOTE: ASCII characters not allowed in URLs, delimiter characters
      used before or after the |host| component, characters
      percent-encoded in Chrome (See Step 27), ";", and "%" are
      percent-encoded here.

  26: IE: Percent-encode following characters in /s/, using lowercase
      digits: U+0000-U+001F, U+0020, U+0022 ("), U+003C (<), U+003E
      (>), U+005C (\), U+005E (^), U+0060 (`), U+007B ({), U+007C (|),
      U+007D (}), U+007F.

  27. CHROME: Percent-encode following characters in /s/: U+0020,
      U+0021 (!), U+0022 ("), U+0023 (#), U+0024 ($), U+0026 (&),
      U+0027 ('), U+0028 ((), U+0029 ()), U+002A (*), U+002C (,),
      U+003C (<), U+003D (=), U+003E (>), U+0040 (@), U+005E (^),
      U+0060 (`), U+007B ({), U+007C (|), and U+007D (}).

  28: If /s/ is an IPv6 address, return the canonical representation
      of the IPv6 address and abort these steps.

  29: If /s/ contains a U+005B LEFT SQUARE BRACKET character ([) or a
      U+005D RIGHT SQUARE BRACKET (]) character, return /fallback/ and
      abort the CanonicalizeHost algorithm.

  39: If /s/ is an IPv4 address, return the canonical representation
      of the IPv4 address and abort the CanonicalizeHost algorithm.

  40: Return /s/.

* Canonicalize a string /u/ by encoding /encoding/

  XXX Remove characters U+0009, U+000A, and U+000D from /u/.

  If there is the |scheme| component in /u/, replace the component by
  the same string converted to ASCII lowercase [WA1].

  If there is the |user| component or the |password| component in /u/:

    If there is the |password| component in /u/ and it is the empty
    string, remove the |password| component (and preceding U+003A
    COLON character (:)).

    If the |user| component is the empty string and there is no
    |password| component, remove the |user| component (and following
    U+0040 COMMERCIAL AT character (@)).

    Percent-encode characters EXCEPT for unreserved characters, U+0021
    (!), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028 ((),
    U+0029 ()), U+002A (*), U+002B (+), U+002D (,), in the |user|
    component of /u/, using encoding |UTF-8|.

    Percent-encode characters EXCEPT for unreserved characters, U+0021
    (!), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028 ((),
    U+0029 ()), U+002A (*), U+002B (+), U+002D (,), in the |password|
    component of /u/, using encoding |UTF-8|, if any.

  If there is the |host| component, invoke the CanonicalizeHost
  algorithm with the |host| and then:

    If the algorithm returns a string, then let the |host| component
    be the string.  The string can be the empty string.

    Otherwise, if the algorithm fails, /u/ is invalid.  Abort the
    entire steps.

  If there is the |port| component in /u/:

    If the |port| component is the empty string, remove the |port|
    component (and preceding U+003A COLON character (:)).

    Otherwise, if the |port| component consist of one or more sequence
    of characters in the range U+0030 to U+0039, inclusive:

      Interpret the |port| component as a decimal number and let /p/
      be that number.

      If /p/ is equal to the default port of the scheme of /u/, if
      any, remove the |port| component (and preceding U+003A COLON
      character (:)).

      Otherwise, if /p/ is less than or equal to 65535, replace the
      |port| component by the shortest representation of /p/ in
      decimal, using characters in the range U+0030 to U+0039,
      inclusive.

      Otherwise, /u/ is invalid.  Abort the entire steps.

    Otherwise, /u/ is invalid.  Abort the entire steps.

  XXX If no path

  Percent-decode percent-encoded representations of unreserved
  characters in the |path| component of /u/.

  Percent-encode characters EXCEPT for unreserved characters, U+0021
  (!), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028 ((),
  U+0029 ()), U+002A (*), U+002B (+), U+002D (,), U+002F (/), U+003A
  (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([), U+005D (]), in
  the |path| component of /u/, using encoding |UTF-8|.

  Percent-encode characters EXCEPT for unreserved characters, U+0021
  (!), U+0024 ($), U+0025 (%), U+0026 (&), U+0027 ('), U+0028 ((),
  U+0029 ()), U+002A (*), U+002B (+), U+002D (,), U+002F (/), U+003A
  (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([), U+005D (]),
  U+005C (\), U+005E (^), U+0060 (`), U+007B ({), U+007C (|), U+007D
  (}), in the |query| component of /u/, using encoding /encoding/
  [WA1].

  Percent-encode characters U+0000 ... U+0020, U+0022 ("), U+003C (<),
  U+003E (>), U+007F ... U+009F, in the |fragment| component of /u/,
  using encoding |UTF-8|.

  XXX Non-hierarchical

  XXX Non-http

* Serialization of parsed URL

  If the parsed URL is /invalid/, abort these steps.

  Let /s/ be the empty string.

  Append the |scheme| component to /s/.

  Append a U+003A COLON (:) character to /s/.

  If there is at least one of |user|, |password|, |host|, and |port|
  components (even if it is the empty string):

    Append |//| (two U+002F SOLIDUS (/) characters) to /s/.

    If there is at least one of |user| and |password| component (even
    if it is the empty string):

      Append the |user| component, if any, to /s/.

      If there is the |password| component (even if it is the empty
      string):

        Append a U+003A COLON (:) character to /s/.

        Append the |password| component to /s/.

      Append a U+0040 COMMERCIAL AT (@) character to /s/.

    Append the |host| component, if any, to /s/.

    If there is the |port| component (even if it is the empty string):

      Append a U+003A COLON (:) character to /s/.

      Append the |port| component to /s/.

  Append the |path| component, if any, to /s/.

  If there is the |query| component (even if it is the empty string):

    Append a U+003F QUESTION MARK (?) character to /s/.

    Append the |query| component to /s/.

  If there is the |fragment| component (even if it is the empty
  string):

    Append a U+0023 NUMBER SIGN (#) character to /s/.

    Append the |fragment| component to /s/.

  Return /s/.
